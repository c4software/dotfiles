#!/usr/bin/env bash
#    _____    __                 __
#   / __(_)__/ /__ ___  ___ ____/ /
#  _\ \/ / _  / -_) _ \/ _ `/ _  / 
# /___/_/\_,_/\__/ .__/\_,_/\_,_/  
#               /_/                
# Main Script with scale support

# --- Configuration ---
WINDOW_CLASS="sidepad"
HIDDEN_LEFT_GAP=10
VISIBLE_LEFT_GAP=10
TARGET_WIDTH=700
TARGET_WIDTH_MAX=1000
TOP_GAP=100
BOTTOM_GAP=100

# --- Script Variables ---
HIDE_REQUESTED=0

# --- Help Function ---
show_help() {
    echo "Usage: $0 [options]"
    echo "Please make sure that you're using the class only once."
    echo "The window must be in floating mode."
    echo ""
    echo "Options:"
    echo "  --class <name>         Override the window class (Default: $WINDOW_CLASS)"
    echo "  --hidden-gap <px>      Override the hidden left gap (Default: $HIDDEN_LEFT_GAP)"
    echo "  --visible-gap <px>     Override the visible left gap (Default: $VISIBLE_LEFT_GAP)"
    echo "  --width <px>           Override the target width (Default: $TARGET_WIDTH)"
    echo "  --width-max <px>       Override the maximum target width (Default: $TARGET_WIDTH_MAX)"
    echo "  --top-gap <px>         Override the top gap (Default: $TOP_GAP)"
    echo "  --bottom-gap <px>      Override the bottom gap (Default: $BOTTOM_GAP)"
    echo "  --hide                 Force the window to the hidden state."
    echo "  --kill                 Kills the running app with WINDOW_CLASS."
    echo "  --test                 Test for running app with WINDOW_CLASS."
    echo "  -h, --help             Display this help and exit"
    exit 0
}

test_sidepad() {
    if ! hyprctl clients -j | jq -e --arg class "$WINDOW_CLASS" '.[] | select(.class == $class)' > /dev/null; then
        echo "1"
        return 1
    else
        echo "0"
        return 0
    fi
}

init_sidepad() {
    # Check if the window already exists, if not launch it
    if ! hyprctl clients -j | jq -e --arg class "$WINDOW_CLASS" '.[] | select(.class == $class)' > /dev/null; then
        if [[ "$WINDOW_CLASS" == "sidepad" ]]; then
            eval "$1 --class $WINDOW_CLASS" &
        else
            eval "$1" &
        fi
        # Wait for the window to appear, with a timeout
        for i in {1..50}; do # ~2 seconds timeout
            if hyprctl clients -j | jq -e --arg class "$WINDOW_CLASS" '.[] | select(.class == $class)' > /dev/null; then
                break
            fi
            sleep 0.1
        done
    fi
}

kill_sidepad() {
    WINDOW_PID=$(hyprctl clients -j | jq -r --arg class "$WINDOW_CLASS" '.[] | select(.class == $class) | .pid')
    if [ -n "$WINDOW_PID" ] && [ "$WINDOW_PID" -ne -1 ]; then
        echo "Killing process with PID $WINDOW_PID for window class '$WINDOW_CLASS'."
        kill "$WINDOW_PID"
    else
        echo "Error: Window with class '$WINDOW_CLASS' not found or has no valid PID." >&2
    fi
    sleep 1
    exit 0
}

# --- Parse Command-line Options ---
while [[ $# -gt 0 ]]; do
    key="$1"
    case $key in
        --class)
            WINDOW_CLASS="$2"
            shift; shift
        ;;

        --hidden-gap)
            HIDDEN_LEFT_GAP="$2"
            shift; shift
        ;;

        --visible-gap)
            VISIBLE_LEFT_GAP="$2"
            shift; shift
        ;;

        --width)
            TARGET_WIDTH="$2"
            shift; shift
        ;;

        --width-max)
            TARGET_WIDTH_MAX="$2"
            shift; shift
        ;;

        --top-gap)
            TOP_GAP="$2"
            shift; shift
        ;;

        --bottom-gap)
            BOTTOM_GAP="$2"
            shift; shift
        ;;

        --hide)
            HIDE_REQUESTED=1
            shift
        ;;

        --test)
            test_sidepad
            exit 0
        ;;

        --kill)
            kill_sidepad
        ;;

        --init)
            SIDEPAD_APP="$2"
            init_sidepad "$SIDEPAD_APP"
            HIDE_REQUESTED=1
            shift 2
        ;;

        -h|--help)
            show_help
        ;;

        *)
            # unknown option
            shift
        ;;
    esac
done

# --- Get Window, Monitor Info, AND Scale ---
WINDOW_INFO=$(hyprctl clients -j | jq --arg class "$WINDOW_CLASS" '.[] | select(.class == $class)')
MONITOR_INFO=$(hyprctl monitors -j | jq -r '.[] | select(.focused == true)')

if [ -z "$WINDOW_INFO" ]; then
    echo "Error: Window with class '$WINDOW_CLASS' not found. Is the window open?"
    exit 1
fi

# Récupérer le facteur de scale
MONITOR_SCALE=$(echo "$MONITOR_INFO" | jq -r '.scale')
if [ -z "$MONITOR_SCALE" ] || [ "$MONITOR_SCALE" == "null" ]; then
    MONITOR_SCALE=1
fi

# Récupérer fenêtre info
WINDOW_ADDRESS=$(echo "$WINDOW_INFO" | jq -r '.address')
# On suppose que size & at sont dans l’espace logique (non-scalé),
# sinon il faudra diviser par scale si c’est des valeurs physiques
WINDOW_WIDTH=$(echo "$WINDOW_INFO" | jq -r '.size[0]')
WINDOW_HEIGHT=$(echo "$WINDOW_INFO" | jq -r '.size[1]')
WINDOW_X=$(echo "$WINDOW_INFO" | jq -r '.at[0]')
WINDOW_Y=$(echo "$WINDOW_INFO" | jq -r '.at[1]')

# Ajustement pour le scale
# Si les valeurs actuelles sont *en pixels physiques*, les transformer en logiques
# en divisant par scale. Sinon, sauter cette étape.
# Supposons ici que size et at sont *en pixels logiques*, donc les gaps/width doivent être multipliés par scale lors du dispatch.

# --- Main Logic ---

# Case 1: --hide flag is used, unconditionally hide the window.
if [[ "$HIDE_REQUESTED" -eq 1 ]]; then
    if (( WINDOW_X >= 0 )); then # Only act if it is not already hidden
        echo "--- Hiding window (--hide) ---"
        # Calculs avec scale
        # On ajuste la TARGET_WIDTH en pixels logiques * scale
        SCALED_TARGET_WIDTH=$(( TARGET_WIDTH * MONITOR_SCALE ))
        SCALED_HIDDEN_LEFT_GAP=$(( HIDDEN_LEFT_GAP * MONITOR_SCALE ))
        SCALED_TOP_GAP=$(( TOP_GAP * MONITOR_SCALE ))
        SCALED_BOTTOM_GAP=$(( BOTTOM_GAP * MONITOR_SCALE ))

        PIXELS_TO_MOVE_X=$(( (WINDOW_X * -1) - SCALED_TARGET_WIDTH + SCALED_HIDDEN_LEFT_GAP ))
        PIXELS_TO_MOVE_Y=$(( SCALED_TOP_GAP - WINDOW_Y ))
        SCALED_MONITOR_HEIGHT=$(( ($(echo "$MONITOR_INFO" | jq -r '.height') ) * MONITOR_SCALE ))
        TARGET_HEIGHT=$(( SCALED_MONITOR_HEIGHT - SCALED_TOP_GAP - SCALED_BOTTOM_GAP ))

        hyprctl --batch "dispatch resizewindowpixel exact $SCALED_TARGET_WIDTH $TARGET_HEIGHT,address:$WINDOW_ADDRESS; dispatch movewindowpixel $PIXELS_TO_MOVE_X $PIXELS_TO_MOVE_Y,address:$WINDOW_ADDRESS"
        
        # Give the focus back to the previous window (alt tab)
        hyprctl dispatch cyclenext prev

        # movecursor to the active window
        ACTIVE_WINDOW_INFO=$(hyprctl activewindow -j)
        ACTIVE_WINDOW_X=$(echo "$ACTIVE_WINDOW_INFO" | jq -r '.at[0]')
        ACTIVE_WINDOW_Y=$(echo "$ACTIVE_WINDOW_INFO" | jq -r '.at[1]')
        hyprctl dispatch movecursor $ACTIVE_WINDOW_X $ACTIVE_WINDOW_Y
        
        echo "Operation completed."
    else
        echo "Window is already hidden."
    fi
    exit 0
fi

# Case 2: Window is hidden, so show it.
if (( WINDOW_X < 0 )); then
    echo "--- Showing window ---"
    # Calculs avec scale
    SCALED_TARGET_WIDTH=$(( TARGET_WIDTH * MONITOR_SCALE ))
    SCALED_VISIBLE_LEFT_GAP=$(( VISIBLE_LEFT_GAP * MONITOR_SCALE ))
    SCALED_TOP_GAP=$(( TOP_GAP * MONITOR_SCALE ))
    SCALED_BOTTOM_GAP=$(( BOTTOM_GAP * MONITOR_SCALE ))

    PIXELS_TO_MOVE_X=$(( SCALED_VISIBLE_LEFT_GAP - WINDOW_X ))
    PIXELS_TO_MOVE_Y=$(( SCALED_TOP_GAP - WINDOW_Y ))
    SCALED_MONITOR_HEIGHT=$(( ($(echo "$MONITOR_INFO" | jq -r '.height') ) * MONITOR_SCALE ))
    TARGET_HEIGHT=$(( SCALED_MONITOR_height - SCALED_TOP_GAP - SCALED_BOTTOM_GAP ))

    hyprctl --batch "dispatch resizewindowpixel exact $SCALED_TARGET_WIDTH $TARGET_HEIGHT,address:$WINDOW_ADDRESS; dispatch movewindowpixel $PIXELS_TO_MOVE_X $PIXELS_TO_MOVE_Y,address:$WINDOW_ADDRESS"

    # Give focus to the window
    hyprctl dispatch focuswindow address:$WINDOW_ADDRESS

    echo "Operation completed."

# Case 3: Window is visible, so toggle its width and correct its position.
else
    echo "--- Toggling visibility/width ---"
    # Ajustements
    SCALED_TOP_GAP=$(( TOP_GAP * MONITOR_SCALE ))
    SCALED_BOTTOM_GAP=$(( BOTTOM_GAP * MONITOR_SCALE ))
    SCALED_MONITOR_HEIGHT=$(( ($(echo "$MONITOR_INFO" | jq -r '.height') ) * MONITOR_SCALE ))

    PIXELS_TO_MOVE_Y=$(( SCALED_TOP_GAP - WINDOW_Y ))
    TARGET_HEIGHT=$(( SCALED_MONITOR_HEIGHT - SCALED_TOP_GAP - SCALED_BOTTOM_GAP ))
    
    # Horizontal reste
    PIXELS_TO_MOVE_X=0

    # Calculer target width
    # comparer WINDOW_WIDTH * scale avec TARGET_WIDTH_scaled ?
    SCALED_TARGET_WIDTH=$(( TARGET_WIDTH * MONITOR_SCALE ))
    SCALED_TARGET_WIDTH_MAX=$(( TARGET_WIDTH_MAX * MONITOR_SCALE ))

    WIDTH_COMPARE=$(( WINDOW_WIDTH * MONITOR_SCALE ))

    if (( WIDTH_COMPARE == SCALED_TARGET_WIDTH )); then
        echo "--- Expanding width to max ---"
        TARGET_WIDTH_FINAL=$SCALED_TARGET_WIDTH_MAX
    else
        echo "--- Shrinking width to default ---"
        TARGET_WIDTH_FINAL=$SCALED_TARGET_WIDTH
    fi

    hyprctl --batch "dispatch resizewindowpixel exact $TARGET_WIDTH_FINAL $TARGET_HEIGHT,address:$WINDOW_ADDRESS; dispatch movewindowpixel $PIXELS_TO_MOVE_X $PIXELS_TO_MOVE_Y,address:$WINDOW_ADDRESS"
    
    # Give focus to the window
    hyprctl dispatch focuswindow address:$WINDOW_ADDRESS

    # Put the cursor on the window
    hyprctl dispatch mousemove address:$WINDOW_ADDRESS

    echo "Operation completed."
fi
