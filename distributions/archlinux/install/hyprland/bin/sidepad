#!/usr/bin/env bash
# Sidepad script — gestion du scale (float) pour Hyprland

WINDOW_CLASS="sidepad"
HIDDEN_LEFT_GAP=10
VISIBLE_LEFT_GAP=10
TARGET_WIDTH=700
TARGET_WIDTH_MAX=1000
TOP_GAP=100
BOTTOM_GAP=100

HIDE_REQUESTED=0

show_help() {
    echo "Usage: $0 [options]"
    echo ""
    echo "Options:"
    echo "  --class <name>         Override the window class (Default: $WINDOW_CLASS)"
    echo "  --hidden-gap <px>      Override the hidden left gap (Default: $HIDDEN_LEFT_GAP)"
    echo "  --visible-gap <px>     Override the visible left gap (Default: $VISIBLE_LEFT_GAP)"
    echo "  --width <px>           Override the target width (Default: $TARGET_WIDTH)"
    echo "  --width-max <px>       Override the maximum target width (Default: $TARGET_WIDTH_MAX)"
    echo "  --top-gap <px>         Override the top gap (Default: $TOP_GAP)"
    echo "  --bottom-gap <px>      Override the bottom gap (Default: $BOTTOM_GAP)"
    echo "  --hide                 Force the window to the hidden state."
    echo "  --kill                 Kills the running app with WINDOW_CLASS."
    echo "  --test                 Test for running app with WINDOW_CLASS."
    echo "  -h, --help             Display this help and exit"
    exit 0
}

test_sidepad() {
    if ! hyprctl clients -j | jq -e --arg class "$WINDOW_CLASS" '.[] | select(.class == $class)' > /dev/null; then
        echo "1"; return 1
    else
        echo "0"; return 0
    fi
}

init_sidepad() {
    if ! hyprctl clients -j | jq -e --arg class "$WINDOW_CLASS" '.[] | select(.class == $class)' > /dev/null; then
        if [[ "$WINDOW_CLASS" == "sidepad" ]]; then
            eval "$1 --class $WINDOW_CLASS" &
        else
            eval "$1" &
        fi
        for i in {1..50}; do
            if hyprctl clients -j | jq -e --arg class "$WINDOW_CLASS" '.[] | select(.class == $class)' > /dev/null; then
                break
            fi
            sleep 0.1
        done
    fi
}

kill_sidepad() {
    WINDOW_PID=$(hyprctl clients -j | jq -r --arg class "$WINDOW_CLASS" '.[] | select(.class == $class) | .pid')
    if [ -n "$WINDOW_PID" ] && [ "$WINDOW_PID" -ne -1 ]; then
        echo "Killing process with PID $WINDOW_PID for window class '$WINDOW_CLASS'."
        kill "$WINDOW_PID"
    else
        echo "Error: Window with class '$WINDOW_CLASS' not found or has no valid PID." >&2
    fi
    sleep 1
    exit 0
}

# Parse args
while [[ $# -gt 0 ]]; do
    key="$1"
    case $key in
        --class) WINDOW_CLASS="$2"; shift 2 ;;
        --hidden-gap) HIDDEN_LEFT_GAP="$2"; shift 2 ;;
        --visible-gap) VISIBLE_LEFT_GAP="$2"; shift 2 ;;
        --width) TARGET_WIDTH="$2"; shift 2 ;;
        --width-max) TARGET_WIDTH_MAX="$2"; shift 2 ;;
        --top-gap) TOP_GAP="$2"; shift 2 ;;
        --bottom-gap) BOTTOM_GAP="$2"; shift 2 ;;
        --hide) HIDE_REQUESTED=1; shift ;;
        --test) test_sidepad; exit 0 ;;
        --kill) kill_sidepad ;;
        --init) SIDEPAD_APP="$2"; init_sidepad "$SIDEPAD_APP"; HIDE_REQUESTED=1; shift 2 ;;
        -h|--help) show_help ;;
        *) shift ;;
    esac
done

# --- récupération infos fenetre / moniteur ---
WINDOW_INFO=$(hyprctl clients -j | jq --arg class "$WINDOW_CLASS" '.[] | select(.class == $class)')
MONITOR_INFO=$(hyprctl monitors -j | jq -r '.[] | select(.focused == true)')

if [ -z "$WINDOW_INFO" ]; then
    echo "Error: Window with class '$WINDOW_CLASS' not found. Is the window open?"
    exit 1
fi

# Récupérer scale (peut être "2.00" ou "1.25")
MONITOR_SCALE_RAW=$(echo "$MONITOR_INFO" | jq -r '.scale')
if [ -z "$MONITOR_SCALE_RAW" ] || [ "$MONITOR_SCALE_RAW" = "null" ]; then
    MONITOR_SCALE="1"
else
    # normalize decimal comma -> dot and keep value
    MONITOR_SCALE=$(printf "%s" "$MONITOR_SCALE_RAW" | tr ',' '.')
fi

# helpers pour convertir / multiplier (float -> int arrondi)
to_int() {
    awk -v v="$1" 'BEGIN{printf "%.0f", v}'
}
scale_mul() {
    # usage : scale_mul value -> retourne int arrondi de value * MONITOR_SCALE
    awk -v v="$1" -v s="$MONITOR_SCALE" 'BEGIN{printf "%.0f", v * s}'
}
scale_div() {
    # usage : scale_div value -> retourne int arrondi de value / MONITOR_SCALE
    awk -v v="$1" -v s="$MONITOR_SCALE" 'BEGIN{printf "%.0f", v / s}'
}

WINDOW_ADDRESS=$(echo "$WINDOW_INFO" | jq -r '.address')
WINDOW_WIDTH=$(echo "$WINDOW_INFO" | jq -r '.size[0]')
WINDOW_HEIGHT=$(echo "$WINDOW_INFO" | jq -r '.size[1]')
WINDOW_X=$(echo "$WINDOW_INFO" | jq -r '.at[0]')
WINDOW_Y=$(echo "$WINDOW_INFO" | jq -r '.at[1]')
MONITOR_HEIGHT=$(echo "$MONITOR_INFO" | jq -r '.height')

# for safe integer arithmetic, convert values to ints
WINDOW_WIDTH_I=$(to_int "$WINDOW_WIDTH")
WINDOW_HEIGHT_I=$(to_int "$WINDOW_HEIGHT")
WINDOW_X_I=$(to_int "$WINDOW_X")
WINDOW_Y_I=$(to_int "$WINDOW_Y")
MONITOR_HEIGHT_I=$(to_int "$MONITOR_HEIGHT")

# --- Main Logic ---

# Case 1: hide requested
if [[ "$HIDE_REQUESTED" -eq 1 ]]; then
    if (( WINDOW_X_I >= 0 )); then
        echo "--- Hiding window (--hide) ---"
        SCALED_TARGET_WIDTH=$(scale_mul "$TARGET_WIDTH")
        SCALED_HIDDEN_LEFT_GAP=$(scale_mul "$HIDDEN_LEFT_GAP")
        SCALED_TOP_GAP=$(scale_mul "$TOP_GAP")
        SCALED_BOTTOM_GAP=$(scale_mul "$BOTTOM_GAP")
        SCALED_MONITOR_HEIGHT=$(scale_mul "$MONITOR_HEIGHT_I")

        PIXELS_TO_MOVE_X=$(( (WINDOW_X_I * -1) - SCALED_TARGET_WIDTH + SCALED_HIDDEN_LEFT_GAP ))
        PIXELS_TO_MOVE_Y=$(( SCALED_TOP_GAP - WINDOW_Y_I ))
        TARGET_HEIGHT=$(( SCALED_MONITOR_HEIGHT - SCALED_TOP_GAP - SCALED_BOTTOM_GAP ))

        hyprctl --batch "dispatch resizewindowpixel exact $SCALED_TARGET_WIDTH $TARGET_HEIGHT,address:$WINDOW_ADDRESS; dispatch movewindowpixel $PIXELS_TO_MOVE_X $PIXELS_TO_MOVE_Y,address:$WINDOW_ADDRESS"

        hyprctl dispatch cyclenext prev

        ACTIVE_WINDOW_INFO=$(hyprctl activewindow -j)
        ACTIVE_WINDOW_X=$(echo "$ACTIVE_WINDOW_INFO" | jq -r '.at[0]')
        ACTIVE_WINDOW_Y=$(echo "$ACTIVE_WINDOW_INFO" | jq -r '.at[1]')
        ACTIVE_WINDOW_X_I=$(to_int "$ACTIVE_WINDOW_X")
        ACTIVE_WINDOW_Y_I=$(to_int "$ACTIVE_WINDOW_Y")
        hyprctl dispatch movecursor "$ACTIVE_WINDOW_X_I" "$ACTIVE_WINDOW_Y_I"

        echo "Operation completed."
    else
        echo "Window is already hidden."
    fi
    exit 0
fi

# Case 2: window hidden -> show
if (( WINDOW_X_I < 0 )); then
    echo "--- Showing window ---"
    SCALED_TARGET_WIDTH=$(scale_mul "$TARGET_WIDTH")
    SCALED_VISIBLE_LEFT_GAP=$(scale_mul "$VISIBLE_LEFT_GAP")
    SCALED_TOP_GAP=$(scale_mul "$TOP_GAP")
    SCALED_BOTTOM_GAP=$(scale_mul "$BOTTOM_GAP")
    SCALED_MONITOR_HEIGHT=$(scale_mul "$MONITOR_HEIGHT_I")

    PIXELS_TO_MOVE_X=$(( SCALED_VISIBLE_LEFT_GAP - WINDOW_X_I ))
    PIXELS_TO_MOVE_Y=$(( SCALED_TOP_GAP - WINDOW_Y_I ))
    TARGET_HEIGHT=$(( SCALED_MONITOR_HEIGHT - SCALED_TOP_GAP - SCALED_BOTTOM_GAP ))

    hyprctl --batch "dispatch resizewindowpixel exact $SCALED_TARGET_WIDTH $TARGET_HEIGHT,address:$WINDOW_ADDRESS; dispatch movewindowpixel $PIXELS_TO_MOVE_X $PIXELS_TO_MOVE_Y,address:$WINDOW_ADDRESS"

    hyprctl dispatch focuswindow address:$WINDOW_ADDRESS

    echo "Operation completed."

# Case 3: visible -> toggle width
else
    echo "--- Toggling width/position ---"
    SCALED_TOP_GAP=$(scale_mul "$TOP_GAP")
    SCALED_BOTTOM_GAP=$(scale_mul "$BOTTOM_GAP")
    SCALED_MONITOR_HEIGHT=$(scale_mul "$MONITOR_HEIGHT_I")

    PIXELS_TO_MOVE_Y=$(( SCALED_TOP_GAP - WINDOW_Y_I ))
    TARGET_HEIGHT=$(( SCALED_MONITOR_HEIGHT - SCALED_TOP_GAP - SCALED_BOTTOM_GAP ))
    PIXELS_TO_MOVE_X=0

    SCALED_TARGET_WIDTH=$(scale_mul "$TARGET_WIDTH")
    SCALED_TARGET_WIDTH_MAX=$(scale_mul "$TARGET_WIDTH_MAX")
    WIDTH_COMPARE=$(scale_mul "$WINDOW_WIDTH_I")

    if (( WIDTH_COMPARE == SCALED_TARGET_WIDTH )); then
        echo "--- Expanding width to max ---"
        TARGET_WIDTH_FINAL=$SCALED_TARGET_WIDTH_MAX
    else
        echo "--- Shrinking width to default ---"
        TARGET_WIDTH_FINAL=$SCALED_TARGET_WIDTH
    fi

    hyprctl --batch "dispatch resizewindowpixel exact $TARGET_WIDTH_FINAL $TARGET_HEIGHT,address:$WINDOW_ADDRESS; dispatch movewindowpixel $PIXELS_TO_MOVE_X $PIXELS_TO_MOVE_Y,address:$WINDOW_ADDRESS"

    hyprctl dispatch focuswindow address:$WINDOW_ADDRESS
    hyprctl dispatch mousemove address:$WINDOW_ADDRESS

    echo "Operation completed."
fi
