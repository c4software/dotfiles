#!/bin/bash

set -euo pipefail

CONFIG_FILE="$HOME/.config/hypr/monitors.conf"

menu() {
  local prompt="$1"
  local options="$2"
  local extra="$3"
  local preselect="$4"

  # Convertir extra en array correctement
  local args=()
  if [[ -n "$extra" ]]; then
    read -r -a args <<<"$extra"
  fi

  if [[ -n "$preselect" ]]; then
    local index
    # Utiliser -F pour recherche de cha√Æne exacte et g√©rer les cas o√π grep ne trouve rien
    index=$(echo -e "$options" | grep -nxF "$preselect" | head -1 | cut -d: -f1 || echo "")
    if [[ -n "$index" ]]; then
      args+=("-a" "$((index-1))")  # walker utilise des index bas√©s sur 0
    fi
  fi

  echo -e "$options" | walker --dmenu --theme dmenu_250 -p "$prompt‚Ä¶" "${args[@]}"
}

present_terminal() {
  alacritty --class Omarchy -e bash -c "$1; read -p 'Appuyez sur Entr√©e pour continuer...'"
}

save_config_autogenerated() {
  local -n updated_configs=$1

  mkdir -p "$(dirname "$CONFIG_FILE")"

  local existing_configs=""
  if [[ -f "$CONFIG_FILE" ]]; then
    # Sauvegarder le contenu existant en excluant la section autogenerated
    existing_configs=$(sed '/#autogenerated_start/,/#autogenerated_end/d' "$CONFIG_FILE")
    # Supprimer les lignes vides √† la fin
    existing_configs=$(echo "$existing_configs" | sed -e :a -e '/^\s*$/N;ba' -e 's/\n\s*$//')
  fi

  {
    if [[ -n "$existing_configs" ]]; then
      echo "$existing_configs"
      echo ""
    fi
    echo "#autogenerated_start"
    for line in "${updated_configs[@]}"; do
      echo "$line"
    done
    echo "#autogenerated_end"
  } >"$CONFIG_FILE"
}

main() {
  # V√©rifier que hyprctl est disponible
  if ! command -v hyprctl &> /dev/null; then
    echo "Erreur: hyprctl n'est pas disponible. Assurez-vous que Hyprland est en cours d'ex√©cution." >&2
    exit 1
  fi

  # V√©rifier que jq est disponible
  if ! command -v jq &> /dev/null; then
    echo "Erreur: jq n'est pas install√©. Veuillez l'installer pour utiliser ce script." >&2
    exit 1
  fi

  # V√©rifier que walker est disponible
  if ! command -v walker &> /dev/null; then
    echo "Erreur: walker n'est pas disponible. Veuillez l'installer." >&2
    exit 1
  fi

  monitors_json=$(hyprctl monitors -j 2>/dev/null || echo "[]")

  if [[ -z "$monitors_json" || "$monitors_json" == "[]" ]]; then
    echo "Aucun moniteur d√©tect√© par Hyprland." >&2
    exit 1
  fi

  # Valider que le JSON est correct
  if ! echo "$monitors_json" | jq empty 2>/dev/null; then
    echo "Erreur: Impossible de parser la sortie JSON de hyprctl monitors." >&2
    exit 1
  fi

  monitor_count=$(echo "$monitors_json" | jq 'length')

  if [[ "$monitor_count" -eq 0 ]]; then
    echo "Aucun moniteur trouv√©." >&2
    exit 1
  fi

  # Construire une map des configurations actuelles
  declare -A current_configs
  for ((i=0;i<monitor_count;i++)); do
    monitor=$(echo "$monitors_json" | jq ".[$i]")
    name=$(echo "$monitor" | jq -r ".name")
    width=$(echo "$monitor" | jq -r ".width")
    height=$(echo "$monitor" | jq -r ".height")
    refresh=$(echo "$monitor" | jq -r ".refreshRate | floor")
    scale=$(echo "$monitor" | jq -r ".scale")
    x=$(echo "$monitor" | jq -r ".x")
    y=$(echo "$monitor" | jq -r ".y")

    # V√©rifier que toutes les valeurs sont valides
    if [[ "$name" == "null" || "$width" == "null" || "$height" == "null" ]]; then
      echo "Avertissement: Donn√©es incompl√®tes pour le moniteur $i, ignor√©." >&2
      continue
    fi

    current_configs["$name"]="monitor=$name,${width}x${height}@${refresh}Hz,${x}x${y},$scale"
  done

  if [[ ${#current_configs[@]} -eq 0 ]]; then
    echo "Aucun moniteur valide trouv√©." >&2
    exit 1
  fi

  # L'utilisateur choisit quel moniteur configurer
  monitor_list=$(echo "$monitors_json" | jq -r '.[] |
      select(.name != null and .width != null and .height != null) |
      .name + "\t" +
      (.width|tostring) + "x" + (.height|tostring) + "@" + ((.refreshRate|floor)|tostring) + "Hz" +
      (if .focused then " (actuel)" else "" end)')

  if [[ -z "$monitor_list" ]]; then
    echo "Aucun moniteur valide √† configurer." >&2
    exit 1
  fi

  # Trouver le moniteur focalis√© pour la pr√©s√©lection
  focused_monitor=$(echo "$monitors_json" | jq -r '.[] | select(.focused == true) | .name // empty' | head -1)
  
  # Construire la ligne pr√©s√©lectionn√©e si un moniteur est focalis√©
  preselect_line=""
  if [[ -n "$focused_monitor" ]]; then
    preselect_line=$(echo "$monitor_list" | grep "^$focused_monitor\t" | head -1)
  fi

  selected_monitor_line=$(menu "Quel moniteur configurer" "$monitor_list" "" "$preselect_line")
  if [[ -z "$selected_monitor_line" ]]; then
    echo "Aucune s√©lection. Op√©ration annul√©e."
    exit 0
  fi

  monitor_name=$(echo "$selected_monitor_line" | cut -f1)
  
  # Valider que le moniteur existe toujours
  monitor_details=$(echo "$monitors_json" | jq --arg MON "$monitor_name" '.[] | select(.name == $MON)')
  if [[ -z "$monitor_details" ]]; then
    echo "Erreur: Moniteur $monitor_name non trouv√©." >&2
    exit 1
  fi

  # √âtape 1: options de r√©solution
  available_modes=$(echo "$monitor_details" | jq -r '.availableModes[]? // empty')
  
  options="Automatique (preferred,auto)"
  if (( monitor_count > 1 )); then
    options+="\nD√©sactiver le moniteur"
  fi
  if [[ -n "$available_modes" ]]; then
    options+="\n$available_modes"
  fi

  current_mode=$(echo "$monitor_details" | jq -r '"\(.width)x\(.height)@\(.refreshRate | floor).00Hz"')
  chosen_mode_raw=$(menu "Quelle r√©solution" "$options" "" "$current_mode")
  if [[ -z "$chosen_mode_raw" ]]; then
    echo "Aucune s√©lection. Op√©ration annul√©e."
    exit 0
  fi

  position=$(echo "$monitor_details" | jq -r '"\(.x)x\(.y)"')

  if [[ "$chosen_mode_raw" == "D√©sactiver le moniteur" ]]; then
    config_line="monitor=$monitor_name,disable"
    cmd="hyprctl keyword monitor '$monitor_name,disable'"
  else
    if [[ "$chosen_mode_raw" == "Automatique (preferred,auto)" ]]; then
      chosen_mode="preferred,auto,auto"
    else
      # Nettoyer le mode choisi
      chosen_mode=$(echo "$chosen_mode_raw" | sed -E 's/@([0-9]+)\.[0-9]+Hz/@\1Hz/' | awk '{print $1}')
    fi

    # Toujours demander l'√©chelle
    scale_options="1.00\n1.25\n1.50\n1.75\n2.00"
    current_scale=$(echo "$monitor_details" | jq -r '.scale')
    chosen_scale=$(menu "Quelle √©chelle pour $monitor_name" "$scale_options" "" "$current_scale")
    if [[ -z "$chosen_scale" ]]; then
      echo "Aucune √©chelle s√©lectionn√©e. Op√©ration annul√©e."
      exit 0
    fi

    if [[ "$chosen_mode_raw" == "Automatique (preferred,auto)" ]]; then
      config_line="monitor=$monitor_name,$chosen_mode,$chosen_scale"
      cmd="hyprctl keyword monitor '$monitor_name,$chosen_mode,$chosen_scale'"
    else
      config_line="monitor=$monitor_name,${chosen_mode},$position,$chosen_scale"
      cmd="hyprctl keyword monitor '$monitor_name,${chosen_mode},$position,$chosen_scale'"
    fi
  fi

  # Appliquer la mise √† jour
  terminal_script=$(cat <<EOF
echo "Application de la configuration pour $monitor_name:"
echo "  $config_line"
echo ""
if $cmd; then
  echo "‚úÖ Configuration appliqu√©e avec succ√®s!"
else
  echo "‚ùå Erreur lors de l'application de la configuration"
  exit 1
fi
EOF
)
  present_terminal "$terminal_script"

  # V√©rifier que la commande s'est bien ex√©cut√©e
  if ! eval "$cmd" &>/dev/null; then
    echo "Erreur: La configuration n'a pas pu √™tre appliqu√©e." >&2
    exit 1
  fi

  # Mettre √† jour la map de configuration
  current_configs["$monitor_name"]="$config_line"

  # Sauvegarder tous les moniteurs en pr√©servant les autres
  updated_configs=()
  for m in "${!current_configs[@]}"; do
    updated_configs+=("${current_configs[$m]}")
  done

  save_config_autogenerated updated_configs
  echo "üíæ Configuration sauvegard√©e dans $CONFIG_FILE"

  echo
  # V√©rifier si la commande existe avant de l'appeler
  if command -v omarchy-show-done &> /dev/null; then
    omarchy-show-done
  else
    echo "‚úÖ Configuration termin√©e!"
  fi
}

main "$@"